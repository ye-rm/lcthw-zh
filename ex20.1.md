> [ye-rm](https://github.com/ye-rm)在2025/3/12添加书中EX20，文中提到的视频是没有的

# 练习 20. 高级调试技巧

我已经教过你我超棒的调试宏，而且你也一直在使用它们。我在调试代码时，几乎只使用`debug()`宏来分析程序的运行情况并追踪问题。在这个练习中，我将教你使用 GDB 检查一个运行但不退出的简单程序的基础知识。你将学习如何使用 GDB 附加到一个正在运行的进程，停止它，并查看发生了什么。之后，我会给你一些使用 GDB 的小技巧。

这又是一个以视频为主的练习，我会在视频中展示我的高级调试技巧。下面的内容是对视频的补充，所以请先观看视频。先看我操作的话，学习调试会容易得多。

#### 调试打印与 GDB

我主要采用 “科学方法” 来进行调试：我先提出可能的原因，然后排除它们或者证明它们就是导致缺陷的原因。很多程序员在使用这种方法时遇到的问题是，他们觉得这会拖慢他们的速度。他们惊慌失措，急于解决漏洞，但在匆忙之中，他们没有意识到自己只是在盲目尝试，并没有收集到任何有用的信息。我发现日志记录（调试打印）能迫使我以科学的方式解决漏洞，而且在大多数情况下，收集信息也更轻松。

此外，我将调试打印作为主要调试工具，还有以下这些原因：

- 通过调试打印变量，你可以看到程序执行的完整跟踪信息，这能让你追踪问题出在哪里。而使用 GDB 时，你必须在各处为你关注的所有内容设置观察点和调试语句，很难获得程序执行的完整跟踪信息。
- 调试打印语句可以留在代码中，当你需要它们时，重新编译代码，它们就会生效。而使用 GDB 时，对于你要查找的每个缺陷，你都必须为其单独配置相同的信息。
- 在运行不正常的服务器上启用调试日志记录更容易，然后在服务器运行时检查日志，查看发生了什么。系统管理员知道如何处理日志记录，但他们不知道如何使用 GDB。
- 打印信息就是更简单。调试器总是晦涩难懂，界面古怪，还存在不一致的地方。而`debug("Yo, dis right? %d", my_stuff);`这样的调试打印语句没有任何复杂之处。
- 当你编写调试打印语句来查找缺陷时，你必须实际分析代码并运用科学方法。你可以把使用调试打印语句看作是 “我假设代码在这里出了问题”。然后当你运行程序时，你的假设就得到了检验，如果代码没有问题，你就可以转移到其他可能出问题的部分。这看起来可能耗时更长，但实际上更快，因为你要经过一个差异诊断的过程，排除可能的原因，直到找到真正的原因。
- 调试打印在单元测试中效果更好。你在工作时实际上可以直接编译调试打印语句，当单元测试出错时，随时查看日志就行。而使用 GDB 的话，你必须在 GDB 下重新运行单元测试，然后逐步跟踪以查看发生了什么。

尽管有以上这些我更依赖调试打印而非 GDB 的原因，但在某些情况下我仍然会使用 GDB，而且我认为你应该拥有任何能帮助你完成工作的工具。有时候，你不得不连接到一个有问题的程序并进行排查。或者，你可能遇到服务器崩溃的情况，只能通过核心转储文件来查明原因。在这些以及其他一些情况下，GDB 就是正确的选择，而且拥有尽可能多的工具来帮助解决问题总是好的。

下面是我使用 GDB、Valgrind 和调试打印的场景区分：

- 我使用 Valgrind 来捕获所有内存错误。如果 Valgrind 出现问题，或者使用 Valgrind 会使程序运行速度过慢，我就会使用 GDB。
- 我使用带调试打印的`print`语句来诊断和修复与逻辑或使用相关的缺陷。在开始使用 Valgrind 之后，这类缺陷大约占所有缺陷的 90%。
- 对于剩下的那些神秘古怪的问题或紧急情况，我使用 GDB 来收集信息。如果 Valgrind 没有发现任何问题，而且我甚至无法打印出我需要的信息，那么我就会使用 GDB 进行排查。在这种情况下，我使用 GDB 完全是为了收集信息。一旦我对发生的情况有了一些头绪，我就会回去编写一个单元测试来复现这个缺陷，然后使用打印语句来找出原因。

### 调试策略

这个过程实际上适用于你正在使用的任何调试技术。我将以使用 GDB 为例来描述它，因为人们在使用调试器时，似乎最容易跳过这个过程。对每一个 bug 都采用这种方法，直到你只在处理非常棘手的问题时才需要它。

- 新建一个名为 notes.txt 的小文本文件，把它当作记录想法、bug、问题等的实验笔记。
- 在使用 GDB 之前，写下你要修复的 bug 以及可能的原因。
- 针对每个可能的原因，写出你认为问题所在的文件和函数，如果你不知道，就直接注明。
- 现在启动 GDB，选择第一个可能的原因，结合相关的文件和函数变量，在相应位置设置断点。
- 使用 GDB 运行程序，确认这是否就是问题的原因。最好的方法是看能否使用 set 命令，轻松修复程序或者让错误立即出现。
- 如果这不是原因，就在 notes.txt 中记录下不是这个原因，并说明为什么。接着排查下一个最容易调试的可能原因，并不断补充信息。

你可能没注意到，这基本上就是科学方法。你先写下一系列假设，然后通过调试来证明或证伪它们。这能让你深入了解更多可能的原因，最终找到真正的原因。这个过程能帮助你在发现某些原因不可能成立后，避免反复排查它们。

你也可以通过调试打印来完成这个过程，唯一的区别是你要把假设写在源代码中，而不是 notes.txt 里。从某种程度上说，调试打印迫使你以科学的方式处理 bug，因为你必须把假设写成打印语句。

### 附加练习

- 找一个图形化调试器，并将其与原始的 GDB 进行比较。当你调试本地程序时，图形化调试器很有用，但如果要调试服务器上的程序，它们就没什么用了。
- 你可以在操作系统中启用核心转储功能，这样当程序崩溃时，你会得到一个核心转储文件。这个文件就像是程序的 “验尸报告”，你可以加载它来查看程序崩溃时发生了什么以及崩溃的原因。修改 ex18.c，使其在运行几次迭代后崩溃，然后尝试获取核心转储文件并进行分析。
